pragma solidity >=0.8.13;

import "@zk-email/contracts/interfaces/IDKIMRegistry.sol";
import "@zk-email/contracts/utils/StringUtils.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "./verifier.sol";

contract Contract is Ownable {
    // Dependent Contracts
    IDKIMRegistry public dkimRegistry;
    Groth16Verifier public verifier;

    // Prover Constants (Auto-generated)
    uint16 public constant pack_size = 31;
    uint16 public constant pubkey_hash_len = 1;
    string public constant domain = "{{sender_domain}}";
{{#each values}}
    uint16 public constant {{name}}_len = {{maxLength}};  // Adapt calculation as needed
{{/each}}
{{#each external_inputs}}
    uint16 public constant {{name}}_len = {{maxLength}};  // Adapt calculation as needed
{{/each}}

    constructor (IDKIMRegistry r, Groth16Verifier v) Ownable(msg.sender) {
        dkimRegistry = r;
        verifier = v;
    }

    function verify(uint[2] calldata a, uint[2][2] calldata b, uint[2] calldata c, uint[] calldata signals) external {
        // verify RSA
        bytes32 ph = bytes32(signals[0]);
        require(dkimRegistry.isDKIMPublicKeyHashValid(domain, ph), "RSA public key incorrect");
{{#each values}}
        // unpack {{name}}
        uint[] memory packed_{{name}} = new uint[]({{name}}_len);
        for (uint i = 0; i < {{name}}_len; i++) {
            packed_{{name}}[i] = signals[i];  // Adjust index as needed
        }
        string memory {{name}}_string = StringUtils.convertPackedBytesToString(packed_{{name}}, pack_size * {{name}}_len, pack_size);
{{/each}}
{{#each external_inputs}}
        // unpack {{name}}
        uint[] memory packed_{{name}} = new uint[]({\{{name}}_len});
        for (uint i = 0; i < {{name}}_len; i++) {
            packed_{{name}}[i] = signals[i];  // Adjust index as needed
        }
        string memory {{name}}_string = StringUtils.convertPackedBytesToString(packed_{{name}}, pack_size * {{name}}_len, pack_size);
{{/each}}
        // Additional logic as required

        // verify proof
        require(verifier.verifyProof(a, b, c, signals));
    }
}