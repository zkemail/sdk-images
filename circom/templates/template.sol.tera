pragma solidity >=0.8.13;

import { IDKIMRegistry } from "@zk-email/contracts/interfaces/IDKIMRegistry.sol";
import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";
import {ZKEmailProof, Proof} from "../contracts/src/ZKEmailProof.sol";

interface IVerifier {
    function verifyProof(
        uint256[2] calldata a,
        uint256[2][2] calldata b,
        uint256[2] calldata c,
        uint256[{{ signal_size }}] calldata input
    )
        external
        view
        returns (bool);
}

contract Contract is Ownable {
    // ============================
    // Type Definitions
    // ============================
    enum ProofType {
        Client,
        Server
    }

    // ============================
    // Dependent Contracts
    // ============================
    IDKIMRegistry public immutable dkimRegistry;
    IVerifier public immutable clientProofVerifier;
    IVerifier public immutable serverProofVerifier;
    ZKEmailProof public immutable proofMinter;

    // ============================
    // Prover Constants (Auto-generated)
    // ============================
    uint16 public constant pack_size = 31;
    string public constant domain = "{{ sender_domain }}";

{% for field in values %}
    uint16 public constant {{ field.name }}_len = {{ field.pack_size }};
{% endfor %}

{% for field in external_inputs %}
    uint16 public constant {{ field.name }}_len = {{ field.pack_size }};
{% endfor %}

    constructor(IDKIMRegistry _dkimRegistry, IVerifier _clientProofVerifier, IVerifier _serverProofVerifier, ZKEmailProof p)
        Ownable(msg.sender)
    {
        require(address(_dkimRegistry) != address(0), "Invalid DKIM registry");
        require(address(_clientProofVerifier) != address(0), "Invalid client proof verifier");
        require(address(_serverProofVerifier) != address(0), "Invalid server proof verifier");
        dkimRegistry = _dkimRegistry;
        clientProofVerifier = _clientProofVerifier;
        serverProofVerifier = _serverProofVerifier;
        proofMinter = p;
    }

    function verify(
        ProofType proofType,
        uint256[2] calldata a,
        uint256[2][2] calldata b,
        uint256[2] calldata c,
        uint256[{{ signal_size }}] calldata signals
    ) external view {
        // verify RSA
        bytes32 ph = bytes32(signals[0]);
        require(dkimRegistry.isDKIMPublicKeyHashValid(domain, ph), "RSA public key incorrect");
        // select target verifier based on proof type
        IVerifier targetVerifier = (proofType == ProofType.Client) ? clientProofVerifier : serverProofVerifier;
        // verify proof
        require(targetVerifier.verifyProof(a, b, c, signals), "Invalid proof");
    }

    function verifyAndMint(uint[2] calldata a, uint[2][2] calldata b, uint[2] calldata c, uint[{{ signal_size }}] calldata signals, address to, string memory blueprintId) external {
        // verify RSA
        bytes32 ph = bytes32(signals[0]);
        require(dkimRegistry.isDKIMPublicKeyHashValid(domain, ph), "RSA public key incorrect");

        // verify proof
        require(verifier.verifyProof(a,b,c,signals), "Invalid proof");

        Proof memory proof = Proof(a, b, c);

        // Convert signals to uint256[]
        uint256[] memory signals256 = new uint256[](signals.length);
        for (uint i = 0; i < signals.length; i++) {
            signals256[i] = uint256(signals[i]);
        }

    {% for field in values %}
        // unpack {{ field.name }}
        uint[] memory packed_{{ field.name }} = new uint[]({{ field.name }}_len);
        for (uint i = 0; i < {{ field.name }}_len; i++) {
            packed_{{ field.name }}[i] = signals[{{ field.start_idx }} + i];
        }
        string memory {{ field.name }}_string = StringUtils.convertPackedBytesToString(packed_{{ field.name }}, pack_size * {{ field.name }}_len, pack_size); 
    {% endfor %}

    {% for field in external_inputs %}
        // unpack {{ field.name }}
        uint[] memory packed_{{ field.name }} = new uint[]({{ field.name }}_len);
        for (uint i = 0; i < {{ field.name }}_len; i++) {
            packed_{{ field.name }}[i] = signals[{{ field.start_idx }} + i];
        }
        string memory {{ field.name }}_string = StringUtils.convertPackedBytesToString(packed_{{ field.name }}, pack_size * {{ field.name }}_len, pack_size); 
    {% endfor %}

        // mint proof
        proofMinter.mintProof(to, blueprintId, address(this), proof, signals256, 
    }
}
