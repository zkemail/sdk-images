// SPDX-License-Identifier: MIT
pragma solidity >=0.8.13;

import { IDKIMRegistry } from "@zk-email/contracts/interfaces/IDKIMRegistry.sol";
import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";
import { ZKEmailProof, Proof } from "../contracts/ZKEmailProof.sol";
import { StringUtils } from "@zk-email/contracts/utils/StringUtils.sol";

/**
 * @dev Interface for a verifier contract
 */
interface IVerifier {
    function verifyProof(
        uint256[2] calldata a,
        uint256[2][2] calldata b,
        uint256[2] calldata c,
        uint256[{{ signal_size }}] calldata input
    )
        external
        view
        returns (bool);
}

/**
 * @title ZK Email Verification Contract
 * @notice This contract handles the verification of zero-knowledge proofs for email verification
 * @dev Implements both client and server-side proof verification with DKIM validation
 */
contract Contract is Ownable {
    /**
     * @notice Enum for the type of proof
     * @dev Client: Proof generated by the client
     * @dev Server: Proof generated by the server
     */
    enum ProofType {
        Client,
        Server
    }

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*             PROVER CONSTANTS (AUTO-GENERATED)              */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
    uint16 public constant pack_size = 31;
    string public constant domain = "{{ sender_domain }}";

{% for field in values %}
    uint16 public constant {{ field.name }}_len = {{ field.pack_size }};
{% endfor %}

{% for field in external_inputs %}
    uint16 public constant {{ field.name }}_len = {{ field.pack_size }};
{% endfor %}

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                    DEPENDENT CONTRACTS                     */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
    IDKIMRegistry public immutable dkimRegistry;
    IVerifier public immutable clientProofVerifier;
    IVerifier public immutable serverProofVerifier;
    ZKEmailProof public immutable proofMinter;

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                      CUSTOM ERRORS                        */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
    error InvalidDKIMRegistry();
    error InvalidClientProofVerifier();
    error InvalidServerProofVerifier();
    error InvalidProofMinter();
    error InvalidRSAKey();
    error InvalidProof();

    /**
     * @notice Constructor for initializing the contract with required dependencies
     * @param _dkimRegistry Address of the DKIM registry contract
     * @param _clientProofVerifier Address of the client proof verifier contract
     * @param _serverProofVerifier Address of the server proof verifier contract
     * @param _proofMinter Address of the proof minter contract
     * @dev All parameters must be non-zero addresses
     */
    constructor(
        IDKIMRegistry _dkimRegistry,
        IVerifier _clientProofVerifier,
        IVerifier _serverProofVerifier,
        ZKEmailProof _proofMinter
    )
        Ownable(msg.sender)
    {
        if (address(_dkimRegistry) == address(0)) revert InvalidDKIMRegistry();
        if (address(_clientProofVerifier) == address(0)) revert InvalidClientProofVerifier();
        if (address(_serverProofVerifier) == address(0)) revert InvalidServerProofVerifier();
        if (address(_proofMinter) == address(0)) revert InvalidProofMinter();

        dkimRegistry = _dkimRegistry;
        clientProofVerifier = _clientProofVerifier;
        serverProofVerifier = _serverProofVerifier;
        proofMinter = _proofMinter;
    }

    /**
     * @notice External function that verifies a proof and mints a new proof NFT
     * @param proofType Type of proof to verify (Client or Server)
     * @param a First part of the proof
     * @param b Second part of the proof
     * @param c Third part of the proof
     * @param signals Array of public signals used in the proof
     * @param to Address to mint the proof NFT to
     * @param blueprintId Identifier for the proof blueprint
     * @dev This function verifies the proof and then mints an NFT representing the proof
     */
    function verifyAndMint(
        ProofType proofType,
        uint256[2] calldata a,
        uint256[2][2] calldata b,
        uint256[2] calldata c,
        uint256[{{ signal_size }}] calldata signals,
        address to,
        uint256 blueprintId
    )
        external
    {
        // verify proof
        _verify(proofType, a, b, c, signals);

        // mint NFT
        _mint(a, b, c, signals, to, blueprintId);
    }

    /**
     * @notice External function that verifies a proof
     * @param proofType Type of proof to verify (Client or Server)
     * @param a First part of the proof
     * @param b Second part of the proof
     * @param c Third part of the proof
     * @param signals Array of public signals used in the proof
     * @dev This is a view function that only performs verification
     */
    function verify(
        ProofType proofType,
        uint256[2] calldata a,
        uint256[2][2] calldata b,
        uint256[2] calldata c,
        uint256[{{ signal_size }}] calldata signals
    )
        external
        view
    {
        _verify(proofType, a, b, c, signals);
    }

   /**
     * @notice Private function to mint a proof NFT
     * @param a First part of the proof
     * @param b Second part of the proof
     * @param c Third part of the proof
     * @param signals Array of public signals used in the proof
     * @param to Address to mint the proof NFT to
     * @param blueprintId Identifier for the proof blueprint
     * @dev This function:
     *      1. Converts signals to uint256[]
     *      2. Unpacks email_subject
     *      3. Mints the proof
     */
    function _mint(
        uint256[2] calldata a,
        uint256[2][2] calldata b,
        uint256[2] calldata c,
        uint256[10] calldata signals,
        address to,
        uint256 blueprintId
    )
        private
    {
        // Convert signals to uint256[]
        uint256[] memory signals256 = new uint256[](signals.length);
        for (uint256 i = 0; i < signals.length; i++) {
            signals256[i] = uint256(signals[i]);
        }

    {% for field in values %}
        // unpack {{ field.name }}
        uint256[] memory packed_{{ field.name }} = new uint256[]({{ field.name }}_len);
        for (uint256 i = 0; i < {{ field.name }}_len; i++) {
            packed_{{ field.name }}[i] = signals[{{ field.start_idx }} + i];
        }
        string memory {{ field.name }}_string =
            StringUtils.convertPackedBytesToString(packed_{{ field.name }}, pack_size * {{ field.name }}_len, pack_size);
    {% endfor %}

    {% for field in external_inputs %}
        // unpack {{ field.name }}
        uint256[] memory packed_{{ field.name }} = new uint256[]({{ field.name }}_len);
        for (uint256 i = 0; i < {{ field.name }}_len; i++) {
            packed_{{ field.name }}[i] = signals[{{ field.start_idx }} + i];
        }
        string memory {{ field.name }}_string =
            StringUtils.convertPackedBytesToString(packed_{{ field.name }}, pack_size * {{ field.name }}_len, pack_size);
    {% endfor %}

        // mint proof
        Proof memory proof = Proof(a, b, c);
        proofMinter.mintProof(to, blueprintId, proof, signals256);
    }

    /**
     * @notice Private function to verify proofs
     * @param proofType Type of proof to verify (Client or Server)
     * @param a First part of the proof
     * @param b Second part of the proof
     * @param c Third part of the proof
     * @param signals Array of public signals used in the proof
     * @dev This function:
     *      1. Verifies the DKIM public key hash (RSA)
     *      2. Selects the target verifier based on the proof type (client or server)
     *      3. Verifies the proof
     *      (The function throws an error if any of the verifications fail)
     */
    function _verify(
        ProofType proofType,
        uint256[2] calldata a,
        uint256[2][2] calldata b,
        uint256[2] calldata c,
        uint256[{{ signal_size }}] calldata signals
    )
        private
        view
    {
        // verify RSA
        bytes32 publicKeyHash = bytes32(signals[0]);
        if (!dkimRegistry.isDKIMPublicKeyHashValid(domain, publicKeyHash)) revert InvalidRSAKey();

        // select target verifier based on proof type
        IVerifier targetVerifier = (proofType == ProofType.Client) ? clientProofVerifier : serverProofVerifier;

        // verify proof
        if (!targetVerifier.verifyProof(a, b, c, signals)) revert InvalidProof();
    }
}
